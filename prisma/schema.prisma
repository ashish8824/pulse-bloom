// prisma/schema.prisma

datasource db {
  provider = "postgresql"
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

// ─────────────────────────────────────────────────────────────────
// USER
//
// New fields added for auth enhancement:
//   isVerified  — false until user clicks email verification link
//   updatedAt   — auto-updated on every write (needed for token invalidation)
// ─────────────────────────────────────────────────────────────────
model User {
  id         String   @id @default(uuid())
  email      String   @unique
  password   String
  name       String
  isVerified Boolean  @default(false) // ← NEW: email must be verified before login is permitted
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt      // ← NEW: tracks last profile mutation

  moods              MoodEntry[]
  habits             Habit[]
  aiInsight          AiInsight?
  refreshTokens      RefreshToken[]        // ← NEW
  emailVerifications EmailVerification[]   // ← NEW
  passwordResets     PasswordReset[]       // ← NEW
}

// ─────────────────────────────────────────────────────────────────
// REFRESH TOKEN
//
// One user can have many active refresh tokens (multi-device support).
//
// Flow:
//   POST /api/auth/login         → creates RefreshToken row, returns token in body
//   POST /api/auth/refresh-token → validates token, rotates it (delete old, create new)
//   POST /api/auth/logout        → deletes the specific RefreshToken row
//
// Security model:
//   • Token stored as plain string (already a 256-bit random hex — no need to hash)
//   • expiresAt checked on every use
//   • isRevoked set on logout (allows audit trail without hard delete)
//   • @@index([token]) for O(1) lookup on every refresh/logout call
// ─────────────────────────────────────────────────────────────────
model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique              // 256-bit random hex generated in service
  userId    String
  expiresAt DateTime                      // set to now() + 7 days on creation
  isRevoked Boolean  @default(false)      // true after logout; row kept for audit
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])   // critical: every refresh request looks up by token
  @@index([userId])  // needed for "logout all devices" (delete all by userId)
}

// ─────────────────────────────────────────────────────────────────
// EMAIL VERIFICATION
//
// Created on register. Deleted after successful verification.
//
// Flow:
//   POST /api/auth/register      → creates row, sends OTP email
//   POST /api/auth/verify-email  → checks OTP + expiry, sets user.isVerified = true, deletes row
//   POST /api/auth/resend-verification → deletes old row, creates new row, sends new OTP
//
// Security:
//   • OTP is a 6-digit number (100000–999999), easy for users to type
//   • expiresAt = now() + 15 minutes (short window reduces brute-force risk)
//   • Rate limiter on resend route prevents OTP spam
//   • Row deleted after use — OTP is single-use
// ─────────────────────────────────────────────────────────────────
model EmailVerification {
  id        String   @id @default(uuid())
  otp       String                        // 6-digit OTP, stored as string
  userId    String
  expiresAt DateTime                      // now() + 15 minutes
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ─────────────────────────────────────────────────────────────────
// PASSWORD RESET
//
// Created when user requests a reset. Deleted after use.
//
// Flow:
//   POST /api/auth/forgot-password  → creates row, sends reset link with token
//   POST /api/auth/reset-password   → validates token + expiry, hashes new password,
//                                      updates user, revokes all refresh tokens, deletes row
//
// Security:
//   • Token = 64-char random hex (crypto.randomBytes(32).toString('hex'))
//   • expiresAt = now() + 1 hour
//   • Resetting password revokes ALL existing refresh tokens (forces re-login everywhere)
//   • Row deleted after use — token is single-use
//   • Always return 200 on forgot-password even if email not found (prevents user enumeration)
// ─────────────────────────────────────────────────────────────────
model PasswordReset {
  id        String   @id @default(uuid())
  token     String   @unique              // 64-char random hex
  userId    String
  expiresAt DateTime                      // now() + 1 hour
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])   // lookup by token on reset
  @@index([userId])
}

// ─────────────────────────────────────────────────────────────────
// MOOD ENTRY (unchanged)
// ─────────────────────────────────────────────────────────────────
model MoodEntry {
  id        String   @id @default(uuid())
  moodScore Int
  emoji     String
  journalId String?
  userId    String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, createdAt])
}

// ─────────────────────────────────────────────────────────────────
// HABIT (unchanged)
// ─────────────────────────────────────────────────────────────────
enum HabitFrequency {
  daily
  weekly
}

enum HabitCategory {
  health
  fitness
  learning
  mindfulness
  productivity
  custom
}

model Habit {
  id            String         @id @default(uuid())
  title         String
  description   String?
  frequency     HabitFrequency
  category      HabitCategory  @default(custom)
  color         String?
  icon          String?
  targetPerWeek Int?
  sortOrder     Int            @default(0)
  isArchived    Boolean        @default(false)
  reminderTime  String?
  reminderOn    Boolean        @default(false)
  userId        String
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  user User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  logs HabitLog[]

  @@unique([userId, title, frequency])
  @@index([userId])
  @@index([reminderOn, reminderTime])
}

// ─────────────────────────────────────────────────────────────────
// HABIT LOG (unchanged)
// ─────────────────────────────────────────────────────────────────
model HabitLog {
  id        String   @id @default(uuid())
  habitId   String
  date      DateTime
  completed Boolean  @default(true)
  note      String?
  createdAt DateTime @default(now())

  habit Habit @relation(fields: [habitId], references: [id], onDelete: Cascade)

  @@unique([habitId, date])
  @@index([habitId])
}

// ─────────────────────────────────────────────────────────────────
// AI INSIGHT CACHE (unchanged)
// ─────────────────────────────────────────────────────────────────
model AiInsight {
  id          String   @id @default(uuid())
  userId      String
  insights    Json
  dataHash    String
  generatedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
  @@index([userId])
}
